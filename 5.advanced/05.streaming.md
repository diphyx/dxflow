---
title: Streaming
description: Enable high-performance data streaming for large datasets and real-time updates
navigation:
    icon: i-hugeicons:activity-02
---

dxflow automatically optimizes data delivery using streaming or buffered responses depending on your needs, ensuring fast response times and efficient resource usage.

::callout{color="blue"}
**Smart Performance**: dxflow automatically chooses the best response method - streaming for large data or real-time updates, buffering for small quick responses.
::

## Architecture Overview

The dxflow engine implements a sophisticated dual-mode HTTP response system supporting both streaming (chunked) and non-streaming (buffered) responses. This architecture optimizes data delivery based on content type and client requirements.

## How It Works

### Response Mode Detection

The engine determines response mode through multiple mechanisms:

| Priority | Method | Example | Purpose |
|----------|--------|---------|---------|
| **1st** | Query Parameter | `?stream=true` | Explicit client control |
| **2nd** | Accept Header | `Accept: application/stream` | Content negotiation |
| **3rd** | Default | No indicator | Non-stream (buffered) |

### Automatic Mode Selection

dxflow intelligently chooses between two response modes:

::card-group
  ::card{title="Stream Mode" icon="i-hugeicons:activity-02"}
  **Progressive Data Transfer**
  - Uses HTTP chunked transfer encoding
  - Sends data immediately without buffering
  - Memory efficient with O(1) per chunk usage
  - Optimal for large datasets and real-time updates
  - Perfect for logs, file listings, SSE events
  ::

  ::card{title="Non-Stream Mode" icon="i-hugeicons:database-02"}
  **Complete Response Buffering**
  - Assembles full response in memory
  - Sends complete payload in single operation
  - Provides Content-Length header
  - Allows error recovery before transmission
  - Better for small queries and transactional data
  ::
::

### Response Structure

All responses use a unified JSON array format with typed chunks:

| Chunk Type | Payload | Purpose | Position |
|------------|---------|---------|----------|
| **status** | HTTP code & message | Response status | First |
| **total** | Result count | Total items | Optional second |
| **entity** | Data items | Actual content | After metadata |

### When Streaming Activates

Streaming mode activates automatically for:

- **Large file directory listings**
- **Workflow execution logs**
- **Real-time status updates**

## Using Streaming

### Enable Streaming Manually

Add the `stream` parameter to any API request:

```bash
# Enable streaming for file listings
curl "http://localhost/api/object/fs/?stream=true"

# Enable streaming for workflow logs
curl "http://localhost/api/workflow/logs?stream=true"
```

### In the Web Interface

The web console automatically uses streaming for:

::tabs
  ::tab-item{label="File Manager" icon="i-hugeicons:folder-02"}
  - Large directory browsing
  - File search results
  - Bulk file operations
  - Archive contents
  ::

  ::tab-item{label="Workflow Monitor" icon="i-hugeicons:workflow-circle-06"}
  - Live log streaming
  - Container status updates
  - Resource usage metrics
  - Execution progress
  ::

  ::tab-item{label="System Status" icon="i-hugeicons:settings-02"}
  - Bridge connection lists
  - Proxy status monitoring
  - Shell session management
  - System health checks
  ::
::

## Performance Benefits

### Streaming vs Buffered

| Aspect | Streaming | Buffered |
|--------|-----------|----------|
| **Response Start** | Immediate | After completion |
| **Memory Usage** | Very Low | Full dataset size |
| **Best For** | Large data, Live updates | Small queries, Simple data |

### Real-World Performance

::callout
**Example**: A directory with 10,000 files starts showing results in ~50ms with streaming vs ~2000ms with buffering, while using 95% less server memory.
::

## Common Use Cases

### File Management

```bash
# Large directory listings automatically use streaming
dxflow object ls /large-directory

# File uploads show real-time progress
dxflow object upload /path/to/large-file
```

### Workflow Monitoring

```bash
# Live workflow logs automatically stream
dxflow workflow logs my-workflow --follow

# Workflow status updates in real-time
dxflow workflow status
```

### System Administration

```bash
# Network connectivity testing with streaming
dxflow ping

# Bridge connection listings
dxflow bridge list
```

## Best Practices

::card-group
  ::card{title="When to Use Streaming" icon="i-hugeicons:activity-02"}
  - File directory with >100 items
  - Live log monitoring
  - Long-running operations
  - Real-time dashboards
  - Large data exports
  ::

  ::card{title="When to Use Buffered" icon="i-hugeicons:database-02"}
  - Quick status checks
  - Small configuration queries
  - Single file information
  - Simple API calls
  - Mobile applications
  ::
::

## Response Format

Both streaming and buffered responses use the same structured JSON array format with three types of chunks:

### Chunk Types

::card-group
  ::card{title="Status Chunk" icon="i-hugeicons:checkmark-circle-02"}
  **Always First**
  - Contains HTTP status code and message
  - Indicates success or error state
  - Required in every response
  ::

  ::card{title="Total Chunk" icon="i-hugeicons:calculator"}
  **Optional Count**
  - Provides total number of items
  - Helps with progress tracking
  - Useful for pagination
  ::

  ::card{title="Entity Chunk" icon="i-hugeicons:database-02"}
  **Actual Data**
  - Contains the real response data
  - Multiple entities for lists
  - Each item wrapped individually
  ::
::

### Example Response Structure

```json
[
  {
    "kind": "status",
    "payload": {
      "code": 200,
      "message": "OK"
    }
  },
  {
    "kind": "total",
    "payload": 1500
  },
  {
    "kind": "entity",
    "payload": {
      "name": "file1.txt",
      "size": 1024,
      "type": "file"
    }
  },
  {
    "kind": "entity",
    "payload": {
      "name": "file2.txt",
      "size": 2048,
      "type": "file"
    }
  }
]
```

### Response Flow

::tabs
  ::tab-item{label="Streaming Mode" icon="i-hugeicons:activity-02"}
  **Progressive Delivery**
  1. Status chunk sent immediately
  2. Total chunk sent if known
  3. Entity chunks sent as processed
  4. Each chunk flushed to client instantly
  ::

  ::tab-item{label="Buffered Mode" icon="i-hugeicons:database-02"}
  **Complete Assembly**
  1. All chunks collected in memory
  2. Complete response built
  3. Entire response sent at once
  4. Client receives full JSON array
  ::
::

### Payload Contents

The `payload` field contains different data depending on the chunk type:

| Chunk Kind | Payload Structure | Example |
|------------|------------------|---------|
| **status** | `{code: number, message: string}` | `{code: 200, message: "OK"}` |
| **total** | `number` | `1500` |
| **entity** | `object` | `{id: 1, name: "item"}` |

### Error Handling

Error responses maintain the same structure:

```json
[
  {
    "kind": "status",
    "payload": {
      "code": 404,
      "message": "File not found"
    }
  }
]
```

::callout{color="green"}
**Client Friendly**: The consistent structure works identically in both streaming and buffered modes, so your applications only need one parsing approach.
::

## Troubleshooting

### If Streaming Seems Slow

1. **Check network conditions** - Streaming needs stable connections
2. **Verify client support** - Some tools don't handle streaming well
3. **Try buffered mode** - Add `?stream=false` to compare
4. **Check server load** - High activity can affect streaming performance

### Common Issues

**Response appears incomplete:**
- Client may not support chunked encoding
- Try with `curl` or modern browsers
- Use `?stream=false` as fallback

**Streaming not working as expected:**
- Verify endpoint supports streaming
- Check client HTTP library compatibility
- Use `curl` to test streaming behavior directly
